<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Job Manager (Firestore & Gemini)</title>
    <!-- Load Tailwind CSS from CDN for easy styling -->
    <script src="https://cdn.tailwindcss.com"></script>
    
    <!-- Custom CSS for distinct styling elements (like the black borders) -->
    <style>
        /* Refined input field styling: applies Tailwind classes plus a distinct, strong border. */
        .input-field { 
            @apply mt-1 block w-full p-3 rounded-lg shadow-xl focus:ring-indigo-500 focus:border-indigo-500; 
            border: 3px solid #000000; /* Distinct Black Border */
        }
        
        /* Ensure radio buttons also have a distinct, solid border for visual consistency */
        input[type="radio"] {
            border: 2px solid #000000;
        }

        /* Container styling for the job list items */
        .jobs-container {
            padding-bottom: 1rem;
            padding-top: 1rem;
        }

        /* Modal styling with transition for smooth appearance/disappearance */
        .modal {
            transition: opacity 0.2s ease-in-out;
        }
    </style>
    
    <script type="module">
        // Import necessary Firebase modules
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { 
            getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged, setPersistence, browserLocalPersistence 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { 
            getFirestore, doc, setDoc, onSnapshot, collection, query, deleteDoc, setLogLevel 
        } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";

        // Enable debug logging for Firebase to help with development and error tracking
        setLogLevel('debug');

        // ==========================================================
        // SECTION 1: FIREBASE INITIALIZATION & GLOBAL STATE
        // ==========================================================
        
        // Global variables provided by the Canvas environment
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;
        
        // Log configuration details for debugging connectivity issues
        console.log("App ID:", appId);
        console.log("Firebase Config:", firebaseConfig);
        console.log("Initial Auth Token Status:", initialAuthToken ? "Present" : "Not Present");

        const DB_COLLECTION = 'jobs';

        let app;        // Firebase App instance
        let db;         // Firestore instance
        let auth;       // Authentication instance
        let userId = null; // Stores the current user's ID after successful authentication
        let allJobs = [];  // Global array to store all job documents fetched from Firestore
        let isAuthReady = false; // Flag to ensure Firestore queries only run after authentication completes

        // --- DOM Elements ---
        const statusDisplay = document.getElementById('authStatus');
        const jobListContainer = document.getElementById('jobList');
        const loadingIndicator = document.getElementById('loadingIndicator');
        const modalElement = document.getElementById('aiModal');
        const modalContentElement = document.getElementById('aiModalContent');
        const modalTitleElement = document.getElementById('aiModalTitle');
        const modalCloseButton = document.getElementById('closeModal');
        const aiLoadingIndicator = document.getElementById('aiLoadingIndicator');


        /**
         * Generates the secure Firestore collection reference path for the current user.
         * Data is stored privately under the user's ID.
         * Path: /artifacts/{appId}/users/{userId}/jobs
         * @returns {object} Firestore CollectionReference object.
         */
        function getJobsCollectionRef() {
            const collectionPath = `artifacts/${appId}/users/${userId}/${DB_COLLECTION}`;
            return collection(db, collectionPath);
        }

        /**
         * Initializes Firebase services (App, Firestore, Auth) and handles user authentication.
         * This function prioritizes waiting for successful authentication before setting up the listener.
         */
        async function initFirebase() {
            try {
                // 1. Initialize Firebase services if not already done
                if (!app) {
                    app = initializeApp(firebaseConfig);
                    db = getFirestore(app);
                    auth = getAuth(app);
                    // Set persistence to keep the user signed in across browser sessions
                    await setPersistence(auth, browserLocalPersistence);
                }
                
                statusDisplay.textContent = 'Authenticating...';
                loadingIndicator.style.display = 'block';

                // 2. Perform initial sign-in using the custom token or anonymously
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                // 3. Set up the final state listener after the initial sign-in attempt
                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        // User is successfully authenticated, set global state
                        userId = user.uid;
                        statusDisplay.textContent = `Status: Authenticated (User ID: ${userId})`;
                        
                        // Prevent the listener from setting up multiple times
                        if (!isAuthReady) {
                             isAuthReady = true;
                             setupRealTimeListener(); // Start listening for job data
                        }
                    } else {
                        // Should not happen after forced sign-in, but handle case where auth fails
                        statusDisplay.textContent = `Error: Authentication failed.`;
                        loadingIndicator.style.display = 'none';
                    }
                });


            } catch (error) {
                console.error("Firebase Initialization or Auth Error:", error);
                statusDisplay.textContent = `Error: Initialization failed. Check console.`;
                loadingIndicator.style.display = 'none';
            }
        }

        /**
         * Establishes a real-time connection to the Firestore database using onSnapshot.
         * This listener automatically updates the global 'allJobs' array and triggers 'renderJobs' 
         * whenever data changes in the cloud. It runs ONLY after authentication is confirmed.
         */
        function setupRealTimeListener() {
            if (!userId) {
                console.error("Listener setup failed: User ID is null.");
                return; // Prevent listener setup until user ID is available
            }

            console.log("Setting up Firestore listener for user:", userId);

            // Create a query for the current user's private job collection
            const jobsQuery = query(getJobsCollectionRef());

            onSnapshot(jobsQuery, (snapshot) => {
                allJobs = [];
                // Map the Firestore snapshot documents to the local allJobs array
                snapshot.forEach((doc) => {
                    allJobs.push({ id: doc.id, ...doc.data() });
                });
                loadingIndicator.style.display = 'none';
                renderJobs(); // Refresh the UI with the latest data
            }, (error) => {
                console.error("Error setting up real-time listener:", error);
                loadingIndicator.style.display = 'none';
                statusDisplay.textContent = `Error loading data: ${error.message}`;
            });
        }
        
        // ==========================================================
        // SECTION 2: AI INTEGRATION (GEMINI API)
        // ==========================================================

        /**
         * Fetch wrapper with exponential backoff and jitter to handle network failures or rate limiting.
         * @param {string} url - The API endpoint URL.
         * @param {object} options - Fetch request configuration (method, headers, body).
         * @param {number} maxRetries - Maximum number of retries.
         */
        async function fetchWithBackoff(url, options, maxRetries = 5) {
            for (let i = 0; i < maxRetries; i++) {
                try {
                    const response = await fetch(url, options);
                    if (!response.ok) {
                        // Check for errors that are safe to retry (429 Rate Limit, 5xx Server Errors)
                        if (response.status === 429 || response.status >= 500) {
                            throw new Error(`Retryable error: ${response.status}`);
                        }
                        throw new Error(`HTTP error! status: ${response.status}`);
                    }
                    return response;
                } catch (error) {
                    // Stop retrying if max attempts reached
                    if (i === maxRetries - 1) {
                        throw error; 
                    }
                    // Calculate exponential delay with jitter (randomness)
                    const delay = Math.pow(2, i) * 1000 + Math.random() * 1000; 
                    await new Promise(resolve => setTimeout(resolve, delay));
                }
            }
        }

        /**
         * Calls the Gemini API to generate content based on the provided parameters.
         * @param {string} prompt - The user query sent to the model.
         * @param {string} systemInstruction - Instructions defining the model's persona and task.
         * @param {boolean} useSearch - Whether to enable Google Search grounding for real-time data.
         * @returns {Promise<{text: string, sources: Array}>} The generated text and any source citations.
         */
        async function generateContent(prompt, systemInstruction, useSearch = false) {
            const model = 'gemini-2.5-flash-preview-09-2025';
            const apiKey = ""; 
            const apiUrl = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${apiKey}`;

            const payload = {
                contents: [{ parts: [{ text: prompt }] }],
                systemInstruction: { parts: [{ text: systemInstruction }] },
                // Conditionally include the tools property if search grounding is requested
                ...(useSearch && { tools: [{ "google_search": {} }] }) 
            };

            const options = {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify(payload)
            };

            try {
                const response = await fetchWithBackoff(apiUrl, options);
                const result = await response.json();
                
                const candidate = result.candidates?.[0];
                if (!candidate || !candidate.content?.parts?.[0]?.text) {
                    throw new Error("Invalid response structure from Gemini API.");
                }

                const text = candidate.content.parts[0].text;
                
                // Extract search grounding sources if they exist
                let sources = [];
                const groundingMetadata = candidate.groundingMetadata;
                if (groundingMetadata && groundingMetadata.groundingAttributions) {
                    sources = groundingMetadata.groundingAttributions
                        .map(attribution => ({
                            uri: attribution.web?.uri,
                            title: attribution.web?.title,
                        }))
                        .filter(source => source.uri && source.title);
                }
                
                return { text, sources };

            } catch (error) {
                console.error("Gemini API call failed:", error);
                // Return a descriptive error message if the API call fails
                return { text: `[AI Generation Failed: ${error.message}]`, sources: [] };
            }
        }
        
        /**
         * Event handler to trigger the AI to generate a professional report based on a specific job's data.
         * @param {string} jobId - The ID of the job document.
         */
        window.generateReport = async function(jobId) {
            const job = allJobs.find(j => j.id === jobId);
            if (!job) return;
            
            // Show modal and loading indicator while the AI request is pending
            modalTitleElement.textContent = `Generating Report for: ${job.title}`;
            modalContentElement.innerHTML = '';
            aiLoadingIndicator.style.display = 'block';
            modalElement.classList.remove('opacity-0', 'pointer-events-none');
            
            const jobType = job.isHackney ? 'Hackney' : (job.isPeabody ? 'Peabody' : 'General');
            const formattedDate = job.dateCompleted || 'No date recorded';
            
            const systemInstruction = "You are a professional administrative assistant for a maintenance company. Your task is to turn raw job data (address, description, completion date) into a clean, well-formatted, single-paragraph professional report or summary suitable for a client invoice or internal documentation. Do not include pricing information. Keep the tone formal and concise.";
            
            const userQuery = `Job Title/Address: ${job.title}. Job Type: ${jobType}. Date Completed: ${formattedDate}. Work Performed/Description: ${job.description || 'No detailed work description provided.'}`;
            
            // Call the AI model (no search grounding needed as we only use provided job data)
            const { text, sources } = await generateContent(userQuery, systemInstruction, false); 
            
            // Hide loading indicator
            aiLoadingIndicator.style.display = 'none';

            // Construct HTML for the report result
            let reportHtml = `<p class="whitespace-pre-wrap">${text}</p>`;
            
            // Add citation footer if sources were found (should be empty for this non-grounded call)
            if (sources.length > 0) {
                reportHtml += `<div class="mt-6 pt-3 border-t border-gray-200">
                    <p class="font-semibold text-sm text-gray-600 mb-2">Sources Consulted:</p>
                    <ul class="list-disc list-inside space-y-1 text-xs text-gray-500">
                        ${sources.map(source => `<li><a href="${source.uri}" target="_blank" class="text-indigo-500 hover:underline">${source.title}</a></li>`).join('')}
                    </ul>
                </div>`;
            }

            modalContentElement.innerHTML = reportHtml;
        }

        // ==========================================================
        // SECTION 3: UTILITIES & DATA PROCESSING
        // ==========================================================

        /**
         * Formats a number as GBP currency string (£XX.XX).
         * @param {number|string} value - The numerical value to format.
         * @returns {string} Formatted currency string.
         */
        function formatCurrency(value) {
            const num = parseFloat(value);
            if (isNaN(num)) return '£0.00';
            return '£' + num.toFixed(2);
        }
        
        /**
         * Determines the job type (Hackney/Peabody/Other) and returns the HTML for display.
         * @param {object} job - The job data object.
         * @returns {string} HTML span element showing the job type.
         */
        function getJobTypeDisplay(job) {
            if (job.isHackney) return '<span class="text-blue-600 font-bold ml-2">Hackney</span>';
            if (job.isPeabody) return '<span class="text-red-600 font-bold ml-2">Peabody</span>';
            return 'Other';
        }

        /**
         * Calculates the date of the Monday (start) for the week containing the job's completion date.
         * This is used to consistently group jobs into weekly sections.
         * @param {string} dateString - The completion date in 'YYYY-MM-DD' format.
         * @returns {string} The Monday's date in 'YYYY-MM-DD' format, or 'Unscheduled'.
         */
        function getWeekStartDate(dateString) {
            if (!dateString) return 'Unscheduled';

            const date = new Date(dateString + 'T00:00:00'); 
            const day = date.getDay(); // 0 = Sunday, 1 = Monday, ..., 6 = Saturday
            // Calculate the difference needed to reach Monday (1)
            const diff = date.getDate() - day + (day === 0 ? -6 : 1); 
            
            const monday = new Date(date.setDate(diff));
            
            return monday.toISOString().split('T')[0];
        }

        /**
         * Formats the week start date into a human-readable date range (e.g., Week of 01/01/2024 – 07/01/2024).
         * @param {string} dateString - The Monday's date in 'YYYY-MM-DD' format or 'Unscheduled'.
         * @returns {string} The formatted date range string.
         */
        function formatWeekRange(dateString) {
            if (dateString === 'Unscheduled') return 'Unscheduled Jobs';
            
            const start = new Date(dateString + 'T00:00:00');
            const end = new Date(start);
            end.setDate(start.getDate() + 6); // Add 6 days to get Sunday
            
            const formatter = new Intl.DateTimeFormat('en-GB', { day: '2-digit', month: '2-digit', year: 'numeric' });

            return `Week of ${formatter.format(start)} – ${formatter.format(end)}`;
        }

        /**
         * Custom click handler for radio buttons. It allows a selected radio button to be unchecked
         * by clicking it again, enabling a "no job type selected" state.
         * Note: The 'wasCheckedBeforeClick' property is added to the DOM element in the edit/init functions.
         */
        window.handleRadioClick = function(event) {
            const radio = event.target;
            
            const wasCheckedBeforeClick = radio.wasCheckedBeforeClick;
            radio.wasCheckedBeforeClick = radio.checked;

            if (wasCheckedBeforeClick) {
                radio.checked = false;
                radio.wasCheckedBeforeClick = false; 
            }
        };

        /**
         * Hides the AI Report modal and clears its content.
         */
        window.closeModal = function() {
            modalElement.classList.add('opacity-0', 'pointer-events-none');
            // Clear content when closed
            modalContentElement.innerHTML = '';
            modalTitleElement.textContent = '';
        }

        // ==========================================================
        // SECTION 4: RENDERING & DISPLAY LOGIC
        // ==========================================================
        
        /**
         * Generates the HTML string for a single read-only job card.
         * This function separates the HTML structure from the main rendering loop for clarity.
         * @param {Object} job - The job data object.
         * @returns {string} The HTML string for the job card.
         */
        function createJobCardHtml(job) {
            // Calculate total cost for display
            const totalCost = (parseFloat(job.labourPrice) || 0) + (parseFloat(job.materialPrice) || 0);
            
            return `
                <div id="job-${job.id}" class="job-card bg-gray-50 p-5 rounded-lg shadow-sm border border-gray-100">
                    <!-- Read-Only Card Content Structure -->
                    <div class="flex justify-between items-start mb-3">
                        <h3 class="text-xl font-bold text-gray-900">${job.title}</h3>
                        <span class="text-sm font-medium text-gray-600">Completed: ${job.dateCompleted || 'N/A'}</span>
                    </div>
                    
                    <!-- Cost Breakdown -->
                    <div class="grid grid-cols-2 gap-x-4 gap-y-2 mb-3 text-sm text-gray-700 border-b pb-2">
                        <div><span class="font-semibold text-gray-600">Labour:</span> ${formatCurrency(job.labourPrice)}</div>
                        <div><span class="font-semibold text-gray-600">Material:</span> ${formatCurrency(job.materialPrice)}</div>
                        <div class="col-span-2 border-t pt-2 mt-1 font-bold text-base text-indigo-700">
                            <span class="font-semibold text-gray-600">TOTAL COST:</span> ${formatCurrency(totalCost)}
                        </div>
                    </div>

                    <!-- Job Type Display -->
                    <div class="mb-4 text-sm font-medium pt-3">
                        <span class="font-semibold text-gray-600">Job Type:</span> 
                        ${getJobTypeDisplay(job)}
                    </div>

                    <!-- Description -->
                    <p class="text-gray-600 mb-4 pt-1">
                        <span class="font-semibold text-gray-600 block mb-1">Description:</span>
                        ${job.description || 'No detailed description provided.'}
                    </p>
                    
                    <!-- Footer Actions (Edit, AI Report, Delete) -->
                    <div class="flex justify-between items-center text-sm text-gray-500 border-t pt-3">
                        <span>Created: ${new Date(job.timestamp).toLocaleDateString()}</span>
                        <div class="flex items-center space-x-2">
                            <button onclick="editJob('${job.id}')" class="text-indigo-600 hover:text-indigo-800 font-semibold transition">Edit</button>
                            
                            <!-- AI Button to generate report -->
                            <button onclick="generateReport('${job.id}')" class="bg-indigo-500 text-white text-xs font-semibold px-3 py-1 rounded-full hover:bg-indigo-600 transition">
                                AI Report
                            </button>
                            
                            <button onclick="deleteJob('${job.id}')" class="text-red-500 hover:text-red-700 transition ml-2">
                                <!-- Trash Can Icon SVG -->
                                <svg class="w-5 h-5 inline" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 7l-.867 12.142A2 2 0 0116.138 21H7.862a2 2 0 01-1.995-1.858L5 7m5 4v6m4-6v6m1-10V4a1 1 0 00-1-1h-4a1 1 0 00-1 1v3M4 7h16"></path></svg>
                            </button>
                        </div>
                    </div>
                </div>
            `;
        }

        /**
         * Main rendering function. Filters, groups, sorts, and displays all jobs.
         * This function is called whenever the data updates (via onSnapshot) or when the search input changes.
         */
        window.renderJobs = function() {
            jobListContainer.innerHTML = ''; // Clear previous content

            const searchTerm = document.getElementById('jobSearch').value.toLowerCase().trim();

            // 1. Apply Search Filter
            let filteredJobs = allJobs;
            if (searchTerm) {
                // Filter jobs if the search term is found in any key field
                filteredJobs = allJobs.filter(job => {
                    const searchableText = [
                        job.title, 
                        job.description, 
                        formatCurrency(job.labourPrice), 
                        formatCurrency(job.materialPrice),
                        job.isHackney ? 'hackney' : '',
                        job.isPeabody ? 'peabody' : ''
                    ].join(' ').toLowerCase();

                    return searchableText.includes(searchTerm);
                });
            }

            if (filteredJobs.length === 0) {
                jobListContainer.innerHTML = `<p class="text-center text-gray-500 py-10">${searchTerm ? 'No jobs match your search criteria.' : 'No jobs found.'}</p>`;
                return;
            }

            // 2. Group jobs by their week start date
            const groupedJobs = filteredJobs.reduce((acc, job) => {
                const weekStartDate = getWeekStartDate(job.dateCompleted);
                if (!acc[weekStartDate]) {
                    acc[weekStartDate] = [];
                }
                acc[weekStartDate].push(job);
                return acc;
            }, {});

            // 3. Sort groups (Puts 'Unscheduled' at the end, then sorts by date descending)
            const sortedGroupKeys = Object.keys(groupedJobs).sort((a, b) => {
                if (a === 'Unscheduled') return 1;
                if (b === 'Unscheduled') return -1;
                return new Date(b) - new Date(a);
            });

            // 4. Render each sorted group header and its job cards
            sortedGroupKeys.forEach(weekStartDate => {
                // Sort jobs within their week by creation time (newest first)
                const weekJobs = groupedJobs[weekStartDate].sort((a, b) => b.timestamp - a.timestamp); 

                const weekTitle = formatWeekRange(weekStartDate);
                // Calculate the total cost for the current week group
                const totalWeekCost = weekJobs.reduce((sum, job) => 
                    sum + (parseFloat(job.labourPrice) || 0) + (parseFloat(job.materialPrice) || 0), 0);
                
                // Create the collapsible group header and container
                const groupElement = document.createElement('div');
                groupElement.className = 'week-group mb-6';
                groupElement.innerHTML = `
                    <!-- Collapsible Header Button with total cost -->
                    <button id="toggle-${weekStartDate}" 
                            class="flex justify-between items-center w-full p-4 bg-indigo-600 text-white rounded-t-xl shadow-md hover:bg-indigo-700 transition" 
                            onclick="toggleWeekDisplay('${weekStartDate}')" aria-expanded="true">
                        <span class="text-xl font-semibold">${weekTitle} (${weekJobs.length} Jobs)</span>
                        <span class="text-xl font-bold">${formatCurrency(totalWeekCost)}</span>
                        <!-- Down/Up Arrow Icon that rotates when toggled -->
                        <svg id="arrow-${weekStartDate}" class="w-6 h-6 transform transition-transform duration-300" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M19 9l-7 7-7-7"></path></svg>
                    </button>
                    <!-- Job Container where cards are placed -->
                    <div id="jobs-${weekStartDate}" class="jobs-container space-y-4 p-4 bg-white border border-t-0 border-gray-200 rounded-b-xl">
                        <!-- Job Cards will be injected here -->
                    </div>
                `;
                jobListContainer.appendChild(groupElement);

                const container = document.getElementById(`jobs-${weekStartDate}`);

                weekJobs.forEach(job => {
                    // Inject the read-only job card HTML
                    container.insertAdjacentHTML('beforeend', createJobCardHtml(job));
                });
                
                // Collapse non-Unscheduled groups by default unless a search term is active
                const shouldCollapse = (weekStartDate !== 'Unscheduled' && !searchTerm);
                if (shouldCollapse) {
                    document.getElementById(`jobs-${weekStartDate}`).style.display = 'none';
                    document.getElementById(`arrow-${weekStartDate}`).classList.add('rotate-180');
                } else {
                    document.getElementById(`jobs-${weekStartDate}`).style.display = 'block';
                    document.getElementById(`arrow-${weekStartDate}`).classList.remove('rotate-180');
                }
            });
        }

        /**
         * Toggles the visibility of a weekly job group when the header button is clicked.
         * @param {string} weekStartDate - The identifier for the group container.
         */
        window.toggleWeekDisplay = function(weekStartDate) {
            const container = document.getElementById(`jobs-${weekStartDate}`);
            const arrow = document.getElementById(`arrow-${weekStartDate}`);
            const isVisible = container.style.display !== 'none';
            
            if (isVisible) {
                container.style.display = 'none';
                arrow.classList.remove('rotate-180'); 
            } else {
                container.style.display = 'block';
                arrow.classList.add('rotate-180'); 
            }
        }

        // ==========================================================
        // SECTION 5: CRUD OPERATIONS (Firestore)
        // ==========================================================

        /**
         * Handles the submission of the new job creation form.
         * Gathers data, validates, and writes a new document to Firestore.
         * @param {Event} event - The form submission event.
         */
        window.addJob = async function(event) {
            event.preventDefault();

            if (!isAuthReady || !userId) {
                console.error("Authentication not ready. Cannot add job.");
                statusDisplay.textContent = 'Error: Authentication not ready. Please wait.';
                return;
            }
            
            // 1. Get DOM elements and values from the creation form
            const addressInput = document.getElementById('jobAddress');
            const labourInput = document.getElementById('labourPrice');
            const materialInput = document.getElementById('materialPrice');
            const descInput = document.getElementById('jobDescription');
            const dateCompletedInput = document.getElementById('dateCompleted'); 

            // Get job type selection (allowing for deselection)
            const jobTypeRadios = document.getElementsByName('jobType');
            let isHackney = false;
            let isPeabody = false;
            
            jobTypeRadios.forEach(radio => {
                if (radio.checked) {
                    if (radio.value === 'hackney') isHackney = true;
                    if (radio.value === 'peabody') isPeabody = true;
                }
            });

            const address = addressInput.value.trim();
            const title = address; // Use address as the main title/identifier
            const description = descInput.value.trim();
            const dateCompleted = dateCompletedInput.value.trim();
            
            // Parse prices, defaulting to 0 if input is empty or invalid
            const labourPrice = parseFloat(labourInput.value) || 0;
            const materialPrice = parseFloat(materialInput.value) || 0;


            if (!title) {
                console.error('Validation Error: The Job Address cannot be empty.');
                return;
            }

            // 2. Create new job object structure
            const jobData = {
                title, 
                address, 
                description,
                labourPrice,
                materialPrice,
                isHackney,
                isPeabody,
                dateCompleted, 
                timestamp: Date.now() // Record creation time for sorting
            };

            // 3. Save job data to Firestore
            try {
                // Get a new document reference with an auto-generated ID
                const newDocRef = doc(getJobsCollectionRef()); 
                await setDoc(newDocRef, jobData);
                
                // Clear form fields for the next entry
                addressInput.value = '';
                labourInput.value = '';
                materialInput.value = '';
                descInput.value = '';
                // Reset radio buttons state
                jobTypeRadios.forEach(radio => {
                    radio.checked = false;
                    radio.wasCheckedBeforeClick = false; 
                });

                // The UI refresh happens automatically via the onSnapshot listener
                console.log("Job added successfully with ID:", newDocRef.id);
            } catch (e) {
                console.error("Error adding document: ", e);
                statusDisplay.textContent = `Error adding job: ${e.message}`;
            }
        }

        /**
         * Deletes a job document from Firestore.
         * @param {string} id - The ID of the job document to delete.
         */
        window.deleteJob = async function(id) {
            if (!isAuthReady || !userId) return;

            try {
                const docRef = doc(getJobsCollectionRef(), id);
                await deleteDoc(docRef);
                // UI refresh is automatic via onSnapshot
            } catch (e) {
                console.error("Error deleting job: ", e);
                statusDisplay.textContent = `Error deleting job: ${e.message}`;
            }
        }
        
        /**
         * Switches the read-only job card element to display the editable form.
         * Pre-fills the form fields with existing job data.
         * @param {string} id - The ID of the job document to edit.
         */
        window.editJob = function(id) {
            const job = allJobs.find(j => j.id === id);
            if (!job) return;

            const cardElement = document.getElementById(`job-${id}`);
            
            // Determine which job type radio button should be checked
            const checkedValue = job.isHackney ? 'hackney' : (job.isPeabody ? 'peabody' : null);
            const jobCompletedDate = job.dateCompleted || '';

            // 1. Generate the HTML for the in-place editable form
            const editFormHtml = `
                <form id="editForm-${id}" class="space-y-4" onsubmit="saveEdit(event, '${id}')">
                    <!-- Address Input (Required) -->
                    <div>
                        <label for="editAddress-${id}" class="block text-sm font-medium text-gray-700">Job Address</label>
                        <input type="text" id="editAddress-${id}" required class="input-field" value="${job.address}">
                    </div>
                    
                    <!-- Date Completed Input -->
                    <div class="mb-4">
                        <label for="editDateCompleted-${id}" class="block text-sm font-medium text-gray-700">Date Completed</label>
                        <input type="date" id="editDateCompleted-${id}" class="input-field" value="${jobCompletedDate}">
                    </div>

                    <!-- Price Inputs (Labour & Material) -->
                    <div class="grid grid-cols-2 gap-4">
                        <div>
                            <label for="editLabourPrice-${id}" class="block text-sm font-medium text-gray-700">Labour Price (£)</label>
                            <input type="number" id="editLabourPrice-${id}" step="0.01" placeholder="0.00" class="input-field" value="${job.labourPrice || ''}">
                        </div>
                        <div>
                            <label for="editMaterialPrice-${id}" class="block text-sm font-medium text-gray-700">Material Price (£)</label>
                            <input type="number" id="editMaterialPrice-${id}" step="0.01" placeholder="0.00" class="input-field" value="${job.materialPrice || ''}">
                        </div>
                    </div>

                    <!-- Description Textarea -->
                    <div>
                        <label for="editDescription-${id}" class="block text-sm font-medium text-gray-700">Detailed Description</label>
                        <textarea id="editDescription-${id}" rows="3" class="input-field">${job.description || ''}</textarea>
                    </div>
                    
                    <!-- Job Type Radios -->
                    <div class="space-y-2">
                        <span class="block text-sm font-medium text-gray-700">Job Type:</span>
                        <div class="flex space-x-6">
                            <div class="flex items-center">
                                <input id="editIsHackney-${id}" type="radio" name="editJobType-${id}" value="hackney" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500" ${checkedValue === 'hackney' ? 'checked' : ''} onclick="handleRadioClick(event)">
                                <label for="editIsHackney-${id}" class="ml-2 block text-sm font-medium text-gray-700">Hackney</label>
                            </div>
                            <div class="flex items-center">
                                <input id="editIsPeabody-${id}" type="radio" name="editJobType-${id}" value="peabody" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500" ${checkedValue === 'peabody' ? 'checked' : ''} onclick="handleRadioClick(event)">
                                <label for="editIsPeabody-${id}" class="ml-2 block text-sm font-medium text-gray-700">Peabody</label>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Action Buttons (Save and Cancel) -->
                    <div class="flex space-x-3 pt-2">
                        <button type="submit" class="flex-1 bg-green-600 text-white font-bold py-2 rounded-lg shadow-md hover:bg-green-700 transition">Save Changes</button>
                        <button type="button" onclick="renderJobs()" class="flex-1 bg-gray-300 text-gray-800 font-bold py-2 rounded-lg shadow-md hover:bg-gray-400 transition">Cancel</button>
                    </div>
                </form>
            `;
            
            // 2. Overwrite the card content with the edit form
            cardElement.innerHTML = editFormHtml;
            
            // 3. Initialize custom radio button state for the newly created form
            const hackneyInput = document.getElementById(`editIsHackney-${id}`);
            const peabodyInput = document.getElementById(`editIsPeabody-${id}`);
            
            if (hackneyInput) hackneyInput.wasCheckedBeforeClick = hackneyInput.checked;
            if (peabodyInput) peabodyInput.wasCheckedBeforeClick = peabodyInput.checked;
        }

        /**
         * Saves the changes made in the edit form back to Firestore.
         * @param {Event} event - The form submission event.
         * @param {string} id - The ID of the job document to update.
         */
        window.saveEdit = async function(event, id) {
            event.preventDefault();

            if (!isAuthReady || !userId) return;
            
            // 1. Get updated values from the edit form
            const addressInput = document.getElementById(`editAddress-${id}`);
            const labourInput = document.getElementById(`editLabourPrice-${id}`);
            const materialInput = document.getElementById(`editMaterialPrice-${id}`);
            const descInput = document.getElementById(`editDescription-${id}`);
            const dateCompletedInput = document.getElementById(`editDateCompleted-${id}`); 
            
            // Check the selected radio button for job type
            const selectedJobType = document.querySelector(`input[name="editJobType-${id}"]:checked`)?.value || '';

            const address = addressInput.value.trim();
            const title = address; 
            const description = descInput.value.trim();
            const dateCompleted = dateCompletedInput.value.trim(); 
            
            const labourPrice = parseFloat(labourInput.value) || 0;
            const materialPrice = parseFloat(materialInput.value) || 0;
            
            const isHackney = selectedJobType === 'hackney';
            const isPeabody = selectedJobType === 'peabody';

            if (!title) {
                console.error('Validation Error: Address cannot be empty.');
                return;
            }

            // 2. Prepare updated data object
            const updatedData = {
                title,
                address,
                description,
                labourPrice,
                materialPrice,
                isHackney,
                isPeabody,
                dateCompleted,
                // Do not update 'timestamp', preserving original creation time
            };
            
            // 3. Write update to Firestore (using merge: true to only update specified fields)
            try {
                const docRef = doc(getJobsCollectionRef(), id);
                await setDoc(docRef, updatedData, { merge: true });
                // The UI will revert to read-only view and refresh automatically
            } catch (e) {
                console.error("Error saving edit:", e);
                statusDisplay.textContent = `Error saving job: ${e.message}`;
            }
        }

        // ==========================================================
        // SECTION 6: INITIALIZATION
        // ==========================================================

        /**
         * Initializes the application by setting up Firebase and DOM event listeners.
         */
        window.onload = function() {
            initFirebase();
            
            // Initialize custom property for the creation form radios on load
            const hackneyCreate = document.getElementById('jobType-hackney');
            const peabodyCreate = document.getElementById('jobType-peabody');

            if (hackneyCreate) hackneyCreate.wasCheckedBeforeClick = hackneyCreate.checked;
            if (peabodyCreate) peabodyCreate.wasCheckedBeforeClick = peabodyCreate.checked;
            
            // Setup listeners for the AI Modal close functionality
            modalCloseButton.addEventListener('click', closeModal);
            modalElement.addEventListener('click', (e) => {
                // If user clicks the background overlay, close the modal
                if (e.target === modalElement) {
                    closeModal(); 
                }
            });
        };

    </script>
</head>
<body class="bg-gray-100 min-h-screen p-4 sm:p-8 font-sans">
    
    <!-- MAIN CONTAINER: Controls the maximum width of the content -->
    <div class="max-w-7xl mx-auto"> 
        
        <!-- NAVIGATION HEADER -->
        <nav class="bg-white p-4 rounded-xl shadow-md flex justify-between items-center mb-6">
            <div class="flex items-center space-x-2">
                <!-- Icon -->
                <svg class="w-7 h-7 text-indigo-600" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 5H7a2 2 0 00-2 2v12a2 2 0 002 2h10a2 2 0 002-2V7a2 2 0 00-2-2h-2M9 5a2 2 0 002 2h2a2 2 0 002-2M9 5a2 2 0 012-2h2a2 2 0 012 2m-3 7h3m-3 4h3m-6-4h.01M9 16h.01"></path></svg>
                <span class="text-xl font-bold text-gray-800">AI Job Manager (Cloud)</span>
            </div>
            <!-- Auth Status Display (shows user ID or status) -->
            <span id="authStatus" class="text-sm text-gray-600">Initializing...</span>
        </nav>

        <h1 class="text-3xl font-extrabold text-gray-800 text-center mb-6">Manage Your Jobs</h1>

        <!-- JOB CREATION FORM SECTION -->
        <div class="bg-white p-6 rounded-xl shadow-lg border border-indigo-200 mb-8">
            <h2 class="text-2xl font-semibold text-gray-800 mb-4">Create New Job</h2>
            <form onsubmit="addJob(event)">

                <!-- Job Address/Title Input -->
                <div class="mb-4">
                    <label for="jobAddress" class="block text-sm font-medium text-gray-700">Job Address (Main Identifier)</label>
                    <input type="text" id="jobAddress" required class="input-field">
                </div>

                <!-- Date Completed Input (used for weekly grouping) -->
                <div class="mb-4">
                    <label for="dateCompleted" class="block text-sm font-medium text-gray-700">Date Completed (For Weekly Grouping)</label>
                    <input type="date" id="dateCompleted" class="input-field">
                </div>

                <!-- Price Inputs (Grid Layout) -->
                <div class="grid grid-cols-2 gap-4 mb-4">
                    <div>
                        <label for="labourPrice" class="block text-sm font-medium text-gray-700">Labour Price (£)</label>
                        <input type="number" id="labourPrice" step="0.01" value="" placeholder="0.00" class="input-field">
                    </div>
                    <div>
                        <label for="materialPrice" class="block text-sm font-medium text-gray-700">Material Price (£)</label>
                        <input type="number" id="materialPrice" step="0.01" value="" placeholder="0.00" class="input-field">
                    </div>
                </div>

                <!-- Description Textarea -->
                <div class="mb-4">
                    <label for="jobDescription" class="block text-sm font-medium text-gray-700">Detailed Description</label>
                    <textarea id="jobDescription" rows="3" class="input-field"></textarea>
                </div>
                
                <!-- Job Type Radio Buttons -->
                <div class="mb-6">
                    <span class="block text-sm font-medium text-gray-700 mb-2">Job Type:</span>
                    <div class="flex space-x-6">
                        <div class="flex items-center">
                            <!-- Radio buttons use the custom click handler to allow unchecking -->
                            <input id="jobType-hackney" type="radio" name="jobType" value="hackney" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500" onclick="handleRadioClick(event)">
                            <label for="jobType-hackney" class="ml-2 block text-sm font-medium text-gray-700">Hackney</label>
                        </div>
                        <div class="flex items-center">
                            <input id="jobType-peabody" type="radio" name="jobType" value="peabody" class="h-4 w-4 text-indigo-600 focus:ring-indigo-500" onclick="handleRadioClick(event)">
                            <label for="jobType-peabody" class="ml-2 block text-sm font-medium text-gray-700">Peabody</label>
                        </div>
                    </div>
                </div>

                <!-- Submission Button -->
                <button type="submit" class="w-full bg-indigo-600 text-white font-bold py-3 rounded-lg shadow-md hover:bg-indigo-700 transition duration-200">
                    Add Job to Cloud
                </button>
            </form>
        </div>

        <!-- JOB LIST DISPLAY SECTION -->
        <h2 class="text-2xl font-semibold text-gray-800 mb-4">Completed Jobs By Week</h2>
        
        <!-- Search Input Field -->
        <div class="relative mb-6">
            <!-- Input triggers renderJobs on every key stroke to filter the list -->
            <input type="text" id="jobSearch" oninput="renderJobs()" placeholder="Search by address, description, or price..." class="input-field pl-10 bg-white">
            <div class="absolute inset-y-0 left-0 flex items-center pl-3 pointer-events-none">
                <!-- Search Icon -->
                <svg class="w-5 h-5 text-gray-400" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M21 21l-6-6m2-5a7 7 0 11-14 0 7 7 0 0114 0z"></path></svg>
            </div>
        </div>
        
        <!-- Loading Indicator for data fetching from Firestore -->
        <div id="loadingIndicator" class="text-center py-8" style="display:none;">
            <svg class="animate-spin h-8 w-8 text-indigo-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
            </svg>
            <p class="mt-2 text-indigo-500">Loading jobs from cloud...</p>
        </div>

        <!-- The container where all job groups and cards are dynamically rendered by JavaScript -->
        <div id="jobList" class="space-y-4">
            <p class="text-center text-gray-500 py-10">Waiting for data connection...</p>
        </div>

    </div>
    
    <!-- AI Report Modal (Initially hidden) -->
    <div id="aiModal" class="modal fixed inset-0 bg-gray-900 bg-opacity-75 flex items-center justify-center z-50 opacity-0 pointer-events-none">
        <div class="bg-white rounded-xl shadow-2xl w-full max-w-2xl m-4 p-6 transform transition-all duration-300">
            
            <!-- Modal Header -->
            <div class="flex justify-between items-center pb-3 border-b border-gray-200">
                <h3 id="aiModalTitle" class="text-2xl font-bold text-indigo-700">AI Report</h3>
                <button id="closeModal" class="text-gray-400 hover:text-gray-600">
                    <!-- Close Icon (X) -->
                    <svg class="w-6 h-6" fill="none" stroke="currentColor" viewBox="0 0 24 24"><path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M6 18L18 6M6 6l12 12"></path></svg>
                </button>
            </div>
            
            <!-- Loading Indicator for AI generation -->
            <div id="aiLoadingIndicator" class="text-center py-8" style="display:none;">
                <svg class="animate-spin h-8 w-8 text-green-500 mx-auto" xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24">
                    <circle class="opacity-25" cx="12" cy="12" r="10" stroke="currentColor" stroke-width="4"></circle>
                    <path class="opacity-75" fill="currentColor" d="M4 12a8 8 0 018-8V0C5.373 0 0 5.373 0 12h4zm2 5.291A7.962 7.962 0 014 12H0c0 3.042 1.135 5.824 3 7.938l3-2.647z"></path>
                </svg>
                <p class="mt-2 text-green-600 font-medium">AI generating professional summary...</p>
            </div>

            <!-- Modal Content (Report Text & Sources) -->
            <div id="aiModalContent" class="py-4 max-h-96 overflow-y-auto text-gray-700 text-base">
                <!-- AI-generated content will be inserted here -->
            </div>
            
            <!-- Modal Footer -->
            <div class="pt-4 border-t border-gray-200 text-right">
                <button onclick="closeModal()" class="bg-gray-500 text-white font-bold py-2 px-4 rounded-lg hover:bg-gray-600 transition">Done</button>
            </div>

        </div>
    </div>

</body>
</html>

